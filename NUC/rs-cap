#!/usr/bin/env python3

import pyrealsense2 as rs
import numpy as np
import matplotlib.pyplot as plt
import cv2
import click
import curses

@click.command()
@click.option(
    '--display/--no-display', 
    default=False, 
    help='Display while recording.'
)
@click.option(
    '--depth-filename',
    required=True,
    help='Filename for depth video output (should end in .avi).'
)
@click.option(
    '--color-filename',
    required=True,
    help='Filename for color video output (should end in .avi).'
)
def rscap(display, depth_filename, color_filename):
    """
    Capture depth and color streams from stereo camera, and save
    the videos to the given filenames.
    """

    if not depth_filename.endswith('.avi') or not color_filename.endswith('.avi'):
        raise Exception('Output filenames must end with \'.avi\'.')

    # TODO: Allow configurable resolution and FPS.
    DIMS = (1280, 720)
    FPS = 30

    # RealSense configuration.
    config = rs.config()
    config.enable_stream(rs.stream.depth, DIMS[0], DIMS[1], rs.format.z16, FPS)
    config.enable_stream(rs.stream.color, DIMS[0], DIMS[1], rs.format.bgr8, FPS)

    # Pipeline for frame capture.
    pipeline = rs.pipeline()
    pipeline.start(config)

    # Create OpenCV video writers for each stream.
    depth_f = cv2.VideoWriter(depth_filename, 0, FPS, DIMS)
    color_f = cv2.VideoWriter(color_filename, cv2.VideoWriter_fourcc(*'XVID'), FPS, DIMS)

    # TODO: Stopping condition.
    while(True):
        
        # Wait for frames.
        frames = pipeline.wait_for_frames()
        depth_frame = frames.get_depth_frame()
        color_frame = frames.get_color_frame()
        if not depth_frame or not color_frame: continue

        # Get np arrays from frames.
        # Get depth and color as numpy arrays.
        depth_data = np.asanyarray(depth_frame.as_frame().get_data())
        color_data = np.asanyarray(color_frame.as_frame().get_data())

        # Display the frames (if we should).
        if display:
            
            depth_colormap = cv2.applyColorMap(
                cv2.convertScaleAbs(depth_data, alpha=0.03), 
                cv2.COLORMAP_JET
            )
            cv2.imshow('depth', depth_colormap)
            cv2.imshow('color', color_data)
            cv2.waitKey(1)

        # Write frames to feed.
        color_f.write(color_data)

        # Need to do some hackery to write depth: pack 16 bytes into
        # two 8-byte channels. B: high byte, G: low byte, R: empty.
        depth_data_BGR = np.array([ 
            depth_data >> 8, 
            depth_data % 2**8,
            0 * depth_data
        ], dtype=np.uint8).transpose([1, 2, 0])

        # import IPython; IPython.embed()

        depth_f.write(depth_data_BGR)

    # Release VideoWriter handles and clean up any windows.
    depth_f.release()
    color_f.release()
    cv2.destroyAllWindows()


if __name__ == '__main__':
    rscap()
